---
name: Build & Push Docker Images

on:
  workflow_call:
    inputs:
      docker_build_context:
        description: "Path to docker build context"
        required: false
        type: string
        default: "."
      docker_build_file:
        description: "Path to the dockerfile within docker_build_context"
        required: false
        type: string
        default: "./Dockerfile"
      push_enabled:
        description: "Set to true to push the image"
        type: boolean
        required: false
        default: false
      push_destinations:
        description: "Expected ';' separated list containing one or more of 'ghcr.io', 'dockerhub'"
        required: false
        type: string
        default: "ghcr.io"
      dockerhub_profile:
        description: "The dockerhub username/profile/organisation the image should be pushed to"
        required: false
        type: string
        default: ""
      dockerhub_repo:
        description: "The dockerhub repository the image should be pushed to"
        required: false
        type: string
        default: ""
      dockerhub_username:
        description: "The dockerhub username. If not given, will revert to dockerhub_profile"
        required: false
        type: string
        default: ""
      ghcr_repo_owner:
        description: "The github username/profile/organisation the repo to be pushed to belongs to"
        required: false
        type: string
        default: ""
      ghcr_repo:
        description: "The ghcr.io repository the image should be pushed to"
        required: false
        type: string
        default: ""
      platform_linux_arm32v6_enabled:
        description: "Set to true to build for the linux/arm/v6 platform"
        type: boolean
        required: false
        default: false
      platform_linux_arm32v7_enabled:
        description: "Set to true to build for the linux/arm/v7 platform"
        type: boolean
        required: false
        default: true
      platform_linux_arm64v8_enabled:
        description: "Set to true to build for the linux/arm64 platform"
        type: boolean
        required: false
        default: true
      platform_linux_amd64_enabled:
        description: "Set to true to build for the linux/amd64 platform"
        type: boolean
        required: false
        default: true
      platform_linux_i386_enabled:
        description: "Set to true to build for the linux/i386 platform"
        type: boolean
        required: false
        default: false
      build_enabled:
        description: "Set to true to build images"
        type: boolean
        required: false
        default: true
      build_platform_specific:
        description: "Set to true to also build platform specific images"
        type: boolean
        required: false
        default: true
      build_latest:
        description: "Set to true to include a latest tag"
        type: boolean
        required: false
        default: true
      build_version_specific:
        description: "Set to true to include a version tag"
        type: boolean
        required: false
        default: true
      get_version_method:
        description: "The method to get the version of the image"
        type: string
        required: false
        default: "file_in_container:file=/IMAGE_VERSION"
      build_nohealthcheck:
        description: "Set to true to build a nohealthcheck version"
        type: boolean
        required: false
        default: true
      build_with_tmpfs:
        description: "Set to true to build with tmpfs"
        type: boolean
        required: false
        default: false
      cache_enabled:
        description: "Use actions/cache to populate cached data"
        type: boolean
        required: false
        default: false
      cache_path:
        description: "The path to restore the cache to"
        type: string
        required: false
        default: ""
      cache_key:
        description: "The cache key to restore"
        type: string
        required: false
        default: ""

    secrets:
      dockerhub_token:
        description: "If pushing to dockerhub, this should be a token for dockerhub_profile"
        required: false
      ghcr_token:
        description: "If pushing to ghcr.io, this should be a github token"
        required: false

jobs:
  workflows_env:
    name: Prepare workflow environment
    runs-on: ubuntu-latest

    outputs:
      docker_build_context: ${{ steps.workflow_env_build.outputs.context }}
      docker_build_file: ${{ steps.workflow_env_build.outputs.file }}
      push_enabled: ${{ steps.workflow_env_push_enabled.outputs.push_enabled }}
      output_dockerhub_enabled: ${{ steps.workflow_env_push_destinations.outputs.dockerhub_enabled }}
      output_ghcr_io_enabled: ${{ steps.workflow_env_push_destinations.outputs.ghcr_io_enabled }}
      dockerhub_profile: ${{ steps.workflow_env_dockerhub_profile.outputs.dockerhub_profile }}
      dockerhub_repo: ${{ steps.workflow_env_dockerhub_repo.outputs.dockerhub_repo }}
      dockerhub_username: ${{ steps.workflow_env_dockerhub_username.outputs.dockerhub_username }}
      ghcr_repo: ${{ steps.workflow_env_ghcr_repo.outputs.ghcr_repo}}
      ghcr_repo_owner: ${{ steps.workflow_env_ghcr_repo_owner.outputs.ghcr_repo_owner}}
      platform_linux_arm32v6_enabled: ${{ steps.workflow_env_platform_enabled.outputs.linux_arm32v6 }}
      platform_linux_arm32v7_enabled: ${{ steps.workflow_env_platform_enabled.outputs.linux_arm32v7 }}
      platform_linux_arm64v8_enabled: ${{ steps.workflow_env_platform_enabled.outputs.linux_arm64 }}
      platform_linux_amd64_enabled: ${{ steps.workflow_env_platform_enabled.outputs.linux_amd64 }}
      platform_linux_i386_enabled: ${{ steps.workflow_env_platform_enabled.outputs.linux_i386 }}
      platforms_csv: ${{ steps.workflow_env_build_multi_arch.outputs.multi_arch_csv }}
      platforms_matrix_json: ${{ steps.workflow_env_build_multi_arch.outputs.multi_arch_matrix_json }}
      build_multi_arch: ${{ steps.workflow_env_build_multi_arch.outputs.build_multi_arch_enabled }}
      build_single_arch: ${{ steps.workflow_env_build_single_arch.outputs.build_single_arch_enabled }}
      build_latest: ${{ steps.workflow_env_build_latest.outputs.build_latest }}
      build_version_specific: ${{ steps.workflow_env_build_version_specific.outputs.build_version_specific }}
      get_version_method: ${{ steps.workflow_env_get_version_method.outputs.method }}
      get_version_method_file_in_container: ${{ steps.workflow_env_get_version_method.outputs.file_in_container }}
      get_version_method_cargo_toml_file_in_image: ${{ steps.workflow_env_get_version_method.outputs.cargo_toml_file_in_image }}
      get_version_method_cargo_toml_file_in_repo: ${{ steps.workflow_env_get_version_method.outputs.cargo_toml_file_in_repo }}
      build_nohealthcheck: ${{ steps.workflow_env_build_nohealthcheck.outputs.build_nohealthcheck }}
      build_with_tmpfs: ${{ steps.workflow_env_build_with_tmpfs.outputs.build_with_tmpfs }}

    steps:
      # Check out code
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # check cache
      - name: "check 'cache_enabled'"
        if: ${{ inputs.cache_enabled }}
        id: workflow_env_check_cache
        uses: actions/cache@v3
        with:
          path: ${{ inputs.cache_path }}
          key: ${{ inputs.cache_key }}
      - name: "ensure cache hit"
        if: ${{ inputs.cache_enabled }}
        env:
          CACHE_HIT: ${{ steps.workflow_env_check_cache.outputs.cache-hit }}
          CACHE_PATH: ${{ inputs.cache_path }}
        run: |
          if [[ "${CACHE_HIT,,}" != "true" ]]; then
            echo "::error title=${{ github.job }}: Cache hit returned false"
            exit 1
          else
            ls -laR "$CACHE_PATH"
          fi

      # Check imported environment variable PUSH_ENABLED
      - name: "check 'push_enabled'"
        id: workflow_env_push_enabled
        env:
          PUSH_ENABLED: ${{ inputs.push_enabled }}
        run: |
          FAIL_STEP=0
          if [[ "${PUSH_ENABLED,,}" == "true" ]]; then
            echo "::set-output name=push_enabled::true"
          elif [[ "${PUSH_ENABLED,,}" == "false" ]]; then
            echo "::set-output name=push_enabled::false"
          else
            echo "::error title=${{ github.job }}: Environment variable invalid::push_enabled should be 'true' or 'false'"
            FAIL_STEP=1
          fi
          exit $FAIL_STEP

      # Check imported environment variable PUSH_DESTINATIONS
      - name: "check 'push_destinations'"
        id: workflow_env_push_destinations
        if: ${{ steps.workflow_env_push_enabled.outputs.push_enabled == 'true' }}
        env:
          PUSH_DESTINATIONS: ${{ inputs.push_destinations }}
        run: |
          FAIL_STEP=0
          echo "::set-output name=ghcr_io_enabled::false"
          echo "::set-output name=dockerhub_enabled::false"
          IFS=';' read -r -a PUSH_DESTINATIONS_ARRAY <<< "$PUSH_DESTINATIONS"
          for PUSH_DESTINATION in "${PUSH_DESTINATIONS_ARRAY[@]}"; do
            if [[ "${PUSH_DESTINATION,,}" == 'ghcr.io' ]]; then
              echo "::set-output name=ghcr_io_enabled::true"
            elif [[ "${PUSH_DESTINATION,,}" == 'dockerhub' ]]; then
              echo "::set-output name=dockerhub_enabled::true"
            else
              echo "::error title=${{ github.job }}: Environment variable invalid::push_destinations includes '$PUSH_DESTINATION'. Expected ';' separated list containing one or more of 'ghcr.io', 'dockerhub'"
              FAIL_STEP=1
            fi
          done
          exit $FAIL_STEP

      # Check imported environment variable dockerhub_profile
      - name: "check 'dockerhub_profile'"
        id: workflow_env_dockerhub_profile
        if: ${{ steps.workflow_env_push_destinations.outputs.dockerhub_enabled == 'true' }}
        env:
          DOCKERHUB_PROFILE: ${{ inputs.dockerhub_profile }}
        run: |
          FAIL_STEP=0
          if [[ -n "${DOCKERHUB_PROFILE}" ]]; then
            echo "::set-output name=dockerhub_profile::$DOCKERHUB_PROFILE"
          else
            echo "::error title=${{ github.job }}: Environment variable invalid::DOCKERHUB_PROFILE is empty"
            FAIL_STEP=1
          fi
          exit $FAIL_STEP

      # Check imported environment variable dockerhub_username
      - name: "check 'dockerhub_username'"
        id: workflow_env_dockerhub_username
        if: ${{ steps.workflow_env_push_destinations.outputs.dockerhub_enabled == 'true' }}
        env:
          DOCKERHUB_USERNAME: ${{ inputs.dockerhub_username }}
          DOCKERHUB_PROFILE: ${{ steps.workflow_env_dockerhub_profile.outputs.dockerhub_profile }}
        run: |
          FAIL_STEP=0
          if [[ -n "${DOCKERHUB_USERNAME}" ]]; then
            echo "::set-output name=dockerhub_username::$DOCKERHUB_USERNAME"
          elif [[ -n "${DOCKERHUB_PROFILE}" ]]; then
            echo "::set-output name=dockerhub_username::$DOCKERHUB_PROFILE"
          else
            echo "::error title=${{ github.job }}: Environment variables invalid::dockerhub_username and dockerhub_profile are empty"
            FAIL_STEP=1
          fi
          exit $FAIL_STEP

      # Check imported environment variable dockerhub_repo
      - name: "check 'dockerhub_repo'"
        id: workflow_env_dockerhub_repo
        if: ${{ steps.workflow_env_push_destinations.outputs.dockerhub_enabled == 'true' }}
        env:
          DOCKERHUB_REPO: ${{ inputs.dockerhub_repo }}
        run: |
          FAIL_STEP=0
          if [[ -n "${DOCKERHUB_REPO}" ]]; then
            echo "::set-output name=dockerhub_repo::$DOCKERHUB_REPO"
          else
            echo "::error title=${{ github.job }}: Environment variable invalid::dockerhub_repo is empty"
            FAIL_STEP=1
          fi
          exit $FAIL_STEP

      # Check imported environment variable ghcr_repo
      - name: "check 'ghcr_repo'"
        id: workflow_env_ghcr_repo
        if: ${{ steps.workflow_env_push_destinations.outputs.ghcr_io_enabled == 'true' }}
        env:
          GHCR_REPO: ${{ inputs.ghcr_repo }}
        run: |
          FAIL_STEP=0
          if [[ -n "${GHCR_REPO}" ]]; then
            echo "::set-output name=ghcr_repo::${GHCR_REPO,,}"
          else
            echo "::error title=${{ github.job }}: Environment variable invalid::ghcr_repo is empty"
            FAIL_STEP=1
          fi
          exit $FAIL_STEP

      # Check imported environment variable ghcr_repo
      - name: "check 'ghcr_repo_owner'"
        id: workflow_env_ghcr_repo_owner
        if: ${{ steps.workflow_env_push_destinations.outputs.ghcr_io_enabled == 'true' }}
        env:
          GHCR_REPO_OWNER: ${{ inputs.ghcr_repo_owner }}
        run: |
          FAIL_STEP=0
          if [[ -n "${GHCR_REPO_OWNER}" ]]; then
            echo "::set-output name=ghcr_repo_owner::${GHCR_REPO_OWNER,,}"
          else
            echo "::error title=${{ github.job }}: Environment variable invalid::ghcr_repo_owner is empty"
            FAIL_STEP=1
          fi
          exit $FAIL_STEP

      # Check imported environment variables PLATFORM_<platform>_ENABLED
      - name: "check 'PLATFORM_<platform>_ENABLED'"
        id: workflow_env_platform_enabled
        env:
          PLATFORM_LINUX_ARM32V6_ENABLED: ${{ inputs.platform_linux_arm32v6_enabled }}
          PLATFORM_LINUX_ARM32V7_ENABLED: ${{ inputs.platform_linux_arm32v7_enabled }}
          PLATFORM_LINUX_ARM64V8_ENABLED: ${{ inputs.platform_linux_arm64v8_enabled }}
          PLATFORM_LINUX_AMD64_ENABLED: ${{ inputs.platform_linux_amd64_enabled }}
          PLATFORM_LINUX_I386_ENABLED: ${{ inputs.platform_linux_i386_enabled }}
        run: |
          set -x
          FAIL_STEP=0
          NUM_ARCHES=0
          if [[ "${PLATFORM_LINUX_ARM32V6_ENABLED,,}" == "true" ]]; then
            echo "::set-output name=linux_arm32v6::true"
            NUM_ARCHES=$((NUM_ARCHES+1))
          fi
          if [[ "${PLATFORM_LINUX_ARM32V7_ENABLED,,}" == "true" ]]; then
            echo "::set-output name=linux_arm32v7::true"
            NUM_ARCHES=$((NUM_ARCHES+1))
          fi
          if [[ "${PLATFORM_LINUX_ARM64V8_ENABLED,,}" == "true" ]]; then
            echo "::set-output name=linux_arm64::true"
            NUM_ARCHES=$((NUM_ARCHES+1))
          fi
          if [[ "${PLATFORM_LINUX_AMD64_ENABLED,,}" == "true" ]]; then
            echo "::set-output name=linux_amd64::true"
            NUM_ARCHES=$((NUM_ARCHES+1))
          fi
          if [[ "${PLATFORM_LINUX_I386_ENABLED,,}" == "true" ]]; then
            echo "::set-output name=linux_i386::true"
            NUM_ARCHES=$((NUM_ARCHES+1))
          fi
          if [[ "$NUM_ARCHES" -le 0 ]]; then
            echo "::error title=${{ github.job }}: Environment variable invalid::platform_<platform>_enabled need at least one platform enabled"
            FAIL_STEP=1
          fi
          exit $FAIL_STEP

      # Check imported environment variables build_enabled
      - name: "check 'build_enabled'"
        id: workflow_env_build_multi_arch
        env:
          BUILD: ${{ inputs.build_enabled }}
        run: |
          set -x
          FAIL_STEP=0
          if [[ "${BUILD,,}" == "true" ]]; then
            echo "::set-output name=build_multi_arch_enabled::true"
            MULTI_ARCH_ARRAY=()
            if [[ "${{ steps.workflow_env_platform_enabled.outputs.linux_arm32v6 }}" == "true" ]]; then
              MULTI_ARCH_ARRAY+=("linux/arm/v6")
            fi
            if [[ "${{ steps.workflow_env_platform_enabled.outputs.linux_arm32v7 }}" == "true" ]]; then
              MULTI_ARCH_ARRAY+=("linux/arm/v7")
            fi
            if [[ "${{ steps.workflow_env_platform_enabled.outputs.linux_arm64 }}" == "true" ]]; then
              MULTI_ARCH_ARRAY+=("linux/arm64")
            fi
            if [[ "${{ steps.workflow_env_platform_enabled.outputs.linux_amd64 }}" == "true" ]]; then
              MULTI_ARCH_ARRAY+=("linux/amd64")
            fi
            if [[ "${{ steps.workflow_env_platform_enabled.outputs.linux_i386 }}" == "true" ]]; then
              MULTI_ARCH_ARRAY+=("linux/i386")
            fi
            printf -v MULTI_ARCH_CSV '%s,' "${MULTI_ARCH_ARRAY[@]}"
            echo "::set-output name=multi_arch_csv::${MULTI_ARCH_CSV::-1}"
            printf -v MULTI_ARCH_JSON '"%s",' "${MULTI_ARCH_ARRAY[@]}"
            echo "::set-output name=multi_arch_matrix_json::{\"platform\":[${MULTI_ARCH_JSON::-1}]}"
          fi
          exit $FAIL_STEP

      # Check imported environment variables build_platform_specific
      - name: "check 'build_platform_specific'"
        id: workflow_env_build_single_arch
        env:
          BUILD_PLATFORM_SPECIFIC: ${{ inputs.build_platform_specific }}
        run: |
          set -x
          FAIL_STEP=0
          if [[ "${BUILD_PLATFORM_SPECIFIC,,}" == "true" ]]; then
            echo "::set-output name=build_single_arch_enabled::true"
          fi
          exit $FAIL_STEP

      # Check imported environment variables build_latest
      - name: "check 'build_latest'"
        id: workflow_env_build_latest
        env:
          BUILD_LATEST: ${{ inputs.build_latest }}
        run: |
          set -x
          FAIL_STEP=0
          if [[ "${BUILD_LATEST,,}" == "true" ]]; then
            echo "::set-output name=build_latest::true"
          fi
          exit $FAIL_STEP

      # Check imported environment variables build_version_specific
      - name: "check 'build_version_specific'"
        id: workflow_env_build_version_specific
        env:
          BUILD_VERSION_SPECIFIC: ${{ inputs.build_version_specific }}
        run: |
          set -x
          FAIL_STEP=0
          if [[ "${BUILD_VERSION_SPECIFIC,,}" == "true" ]]; then
            echo "::set-output name=build_version_specific::true"
          fi
          exit $FAIL_STEP

      - name: "check 'get_version_method'"
        id: workflow_env_get_version_method
        if: steps.workflow_env_build_version_specific.outputs.build_version_specific == 'true'
        env:
          GET_VERSION_METHOD: ${{ inputs.get_version_method }}
        run: |
          set -x
          FAIL_STEP=0
          METHOD=$(echo "$GET_VERSION_METHOD" | cut -d ":" -f 1)
          ARGS=$(echo "$GET_VERSION_METHOD" | cut -d ":" -f 2-)
          case "${METHOD,,}" in
            cargo_toml_file_in_repo)
              echo "::set-output name=method::cargo_toml_file_in_repo"
              FILENAME=$(echo "$ARGS" | grep -E '^[fF][iI][lL][eE]=[\/a-zA-Z0-9\s_\\.\-\(\):]+$' | cut -d "=" -f 2-)
              if [[ -n "$FILENAME" ]]; then
                echo "::set-output name=cargo_toml_file_in_repo::$FILENAME"
              else
                echo "::error title=${{ github.job }}: Environment variable invalid::cargo_toml_file_in_repo method requires valid 'file=' argument"
                FAIL_STEP=1
              fi
              ;;
            cargo_toml_file_in_image)
              echo "::set-output name=method::cargo_toml_file_in_image"
              FILENAME=$(echo "$ARGS" | grep -E '^[fF][iI][lL][eE]=[\/a-zA-Z0-9\s_\\.\-\(\):]+$' | cut -d "=" -f 2-)
              if [[ -n "$FILENAME" ]]; then
                echo "::set-output name=cargo_toml_file_in_image::$FILENAME"
              else
                echo "::error title=${{ github.job }}: Environment variable invalid::cargo_toml_file_in_image method requires valid 'file=' argument"
                FAIL_STEP=1
              fi
              ;;
            file_in_container)
              echo "::set-output name=method::file_in_container"
              FILENAME=$(echo "$ARGS" | grep -E '^[fF][iI][lL][eE]=[\/a-zA-Z0-9\s_\\.\-\(\):]+$' | cut -d "=" -f 2-)
              if [[ -n "$FILENAME" ]]; then
                echo "::set-output name=file_in_container::$FILENAME"
              else
                echo "::error title=${{ github.job }}: Environment variable invalid::file_in_container method requires valid 'file=' argument"
                FAIL_STEP=1
              fi
              ;;
            git_commit_hash_short)
              echo "::set-output name=method::git_commit_hash_short"
              ;;
            *)
              echo "::error title=${{ github.job }}: Environment variable invalid::'$METHOD' method is unsupported. See documentation."
              FAIL_STEP=1
              ;;
          esac
          exit $FAIL_STEP

      - name: "check 'build_nohealthcheck'"
        id: workflow_env_build_nohealthcheck
        env:
          BUILD_NOHEALTHCHECK: ${{ inputs.build_nohealthcheck }}
        run: |
          set -x
          FAIL_STEP=0
          if [[ "${BUILD_NOHEALTHCHECK,,}" == "true" ]]; then
            echo "::set-output name=build_nohealthcheck::true"
          fi
          exit $FAIL_STEP

      # Check imported environment variables docker_build_*
      - name: "check 'docker_build_*'"
        id: workflow_env_build
        env:
          DOCKER_BUILD_CONTEXT: ${{ inputs.docker_build_context }}
          DOCKER_BUILD_FILE: ${{ inputs.docker_build_file }}
        run: |
          set -x
          FAIL_STEP=0
          if [[ -n "${DOCKER_BUILD_CONTEXT}" ]]; then
            echo "::set-output name=context::${DOCKER_BUILD_CONTEXT}"
          else
            FAIL_STEP=1
            echo "::error title=${{ github.job }}: Environment variable invalid::DOCKER_BUILD_CONTEXT is empty"
          fi
          if [[ -n "${DOCKER_BUILD_FILE}" ]]; then
            echo "::set-output name=file::${DOCKER_BUILD_FILE}"
          else
            FAIL_STEP=1
            echo "::error title=${{ github.job }}: Environment variable invalid::DOCKER_BUILD_FILE is empty"
          fi
          exit $FAIL_STEP

      # check for import enviornment variables build_with_tmpfs
      - name: "check 'build_with_tmpfs'"
        id: workflow_env_build_with_tmpfs
        env:
          BUILD_WITH_TMPFS: ${{ inputs.build_with_tmpfs }}
        run: |
          set -x
          FAIL_STEP=0
          if [[ "${BUILD_WITH_TMPFS,,}" == "true" ]]; then
            echo "::set-output name=build_with_tmpfs::true"
          fi
          exit $FAIL_STEP

  build_platform_specific:
    name: Build
    if: ${{ needs.workflows_env.outputs.build_single_arch }}
    runs-on: ubuntu-latest
    needs:
      [
        workflows_env,
        build_nohealthcheck,
        build_platform_specific_nohealthcheck,
      ]
    strategy:
      matrix: ${{fromJson(needs.workflows_env.outputs.platforms_matrix_json)}}

    steps:
      # Check out code
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Populate cache
      - name: "check 'cache_enabled'"
        if: ${{ inputs.cache_enabled }}
        id: populate_cache
        uses: actions/cache@v3
        with:
          path: ${{ inputs.cache_path }}
          key: ${{ inputs.cache_key }}

      # Determine single arch suffix
      - name: Determine platform suffix
        id: platform_suffix
        run: |
          set -x
          ARCH_SUFFIX=$(echo "${{ matrix.platform }}" | tr "/" "_")
          echo "::set-output name=platform_suffix::${ARCH_SUFFIX,,}"

      # Log into dockerhub
      - name: Login to DockerHub
        if: ${{ needs.workflows_env.outputs.output_dockerhub_enabled == 'true' }}
        uses: docker/login-action@v2
        with:
          username: ${{ needs.workflows_env.outputs.dockerhub_username }}
          password: ${{ secrets.dockerhub_token }}

      # Log into ghcr.io
      - name: Login to GitHub Container Registry
        if: ${{ needs.workflows_env.outputs.output_ghcr_io_enabled == 'true' }}
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ needs.workflows_env.outputs.ghcr_repo_owner }}
          password: ${{ secrets.ghcr_token }}

      - name: Run Docker on tmpfs
        if: ${{ needs.workflows_env.outputs.build_with_tmpfs == 'true' }}
        uses: JonasAlfredsson/docker-on-tmpfs@v1
        with:
          tmpfs_size: 5
          swap_size: 4
          swap_location: "/mnt/swapfile"

      # Set up QEMU for multi-arch builds
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      # Set up buildx
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2

      # Cache build of image & get image version from build output
      - name: Cache build of image
        id: cache_build
        uses: docker/build-push-action@v3
        with:
          context: ${{ needs.workflows_env.outputs.docker_build_context }}
          file: ${{ needs.workflows_env.outputs.docker_build_file }}
          platforms: ${{ matrix.platform }}
          tags: cached_build:${{ steps.platform_suffix.outputs.platform_suffix }}
          load: true

      # Determine image version
      - name: Determine image version
        if: ${{ needs.workflows_env.outputs.build_version_specific }}
        id: image_version
        run: |
          set -x
          case "${{ needs.workflows_env.outputs.get_version_method }}" in
            cargo_toml_file_in_repo)
              VERSION=$(cat ./${{ needs.workflows_env.outputs.get_version_method_cargo_toml_file_in_repo }} | grep '\[package\]' -A9999 | grep -m 1 'version = ' | tr -d " " | tr -d '"' | tr -d "'" | cut -d = -f 2 )
              ;;
            cargo_toml_file_in_image)
              VERSION=$(docker run --rm --entrypoint cat cached_build:${{ steps.platform_suffix.outputs.platform_suffix }} ${{ needs.workflows_env.outputs.get_version_method_cargo_toml_file_in_image }} | grep '\[package\]' -A9999 | grep -m 1 'version = ' | tr -d " " | tr -d '"' | tr -d "'" | cut -d = -f 2 )
              ;;
            file_in_container)
              VERSION=$(docker run --rm --entrypoint cat cached_build:${{ steps.platform_suffix.outputs.platform_suffix }} ${{ needs.workflows_env.outputs.get_version_method_file_in_container }})
              ;;
            git_commit_hash_short)
              GIT_HEAD=$(git rev-parse HEAD)
              VERSION="${GIT_HEAD::7}"
              ;;
          esac

          if [[ -z "${VERSION}" ]]; then
            echo "::warning title=${{ github.job }} (${{ matrix.platform }}): No image version::No image version output returned, cannot build version specific images"
            echo "::set-output name=build_version_specific::false"
          else
            echo "::set-output name=build_version_specific::true"
            echo "::set-output name=image_version::${VERSION}"
          fi

      # Determine image names/tags
      - name: Determine image names/tags
        id: image_names_tags
        run: |
          set -x
          IMAGE_NAMES=()
          if [[ "${{ needs.workflows_env.outputs.output_dockerhub_enabled }}" == 'true' ]]; then
            IMAGE_NAMES+=("${{ needs.workflows_env.outputs.dockerhub_profile }}/${{ needs.workflows_env.outputs.dockerhub_repo }}")
          fi
          if [[ "${{ needs.workflows_env.outputs.output_ghcr_io_enabled }}" == 'true' ]]; then
            IMAGE_NAMES+=("ghcr.io/${{ needs.workflows_env.outputs.ghcr_repo }}")
          fi
          if [[ "${{ needs.workflows_env.outputs.push_enabled }}" == "false" ]]; then
            IMAGE_NAMES+=("test_build")
          fi
          printf -v IMAGE_NAMES_CSV '%s,' "${IMAGE_NAMES[@]}"
          echo "::set-output name=names::${IMAGE_NAMES_CSV::-1}"
          IMAGE_TAGS=()
          if [[ ${{ steps.image_version.outputs.build_version_specific }} == "true" ]]; then
            IMAGE_TAGS+=("${{ steps.image_version.outputs.image_version }}_${{ steps.platform_suffix.outputs.platform_suffix }}")
          fi
          if [[ ${{ needs.workflows_env.outputs.build_latest }} == "true" ]]; then
            IMAGE_TAGS+=("latest_${{ steps.platform_suffix.outputs.platform_suffix }}")
          fi
          printf -v IMAGE_TAGS_CSV '%s,' "${IMAGE_TAGS[@]}"
          echo "::set-output name=tags::${IMAGE_TAGS_CSV::-1}"
          IMAGE_FULL_TAGS=()
          for IMAGE_NAME in "${IMAGE_NAMES[@]}"; do
            for IMAGE_TAG in "${IMAGE_TAGS[@]}"; do
              IMAGE_FULL_TAGS+=("$IMAGE_NAME:$IMAGE_TAG")
            done
          done
          printf -v IMAGE_FULL_TAGS_CSV '%s,' "${IMAGE_FULL_TAGS[@]}"
          echo "::set-output name=full_name_tags::${IMAGE_FULL_TAGS_CSV::-1}"

      # Get metadata from repo
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ steps.image_names_tags.outputs.names }}

      # Push final image
      - name: Build & Push Final Image
        id: final_build
        uses: docker/build-push-action@v3
        with:
          context: ${{ needs.workflows_env.outputs.docker_build_context }}
          file: ${{ needs.workflows_env.outputs.docker_build_file }}
          platforms: ${{ matrix.platform }}
          tags: ${{ steps.image_names_tags.outputs.full_name_tags }}
          labels: ${{ steps.meta.outputs.labels }}
          push: ${{ needs.workflows_env.outputs.push_enabled }}

      # Report images
      - name: Log images built & pushed
        if: ${{ needs.workflows_env.outputs.push_enabled == 'true' }}
        run: |
          echo "::notice title=${{ github.job }} (${{ matrix.platform }}): Images built & pushed::${{ steps.image_names_tags.outputs.full_name_tags }}"

  build:
    name: Build (manifest)
    if: ${{ needs.workflows_env.outputs.build_multi_arch }}
    runs-on: ubuntu-latest
    needs:
      [
        workflows_env,
        build_nohealthcheck,
        build_platform_specific_nohealthcheck,
      ]

    steps:
      # Check out code
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Populate cache
      - name: "check 'cache_enabled'"
        if: ${{ inputs.cache_enabled }}
        id: populate_cache
        uses: actions/cache@v3
        with:
          path: ${{ inputs.cache_path }}
          key: ${{ inputs.cache_key }}

      # Log into dockerhub
      - name: Login to DockerHub
        if: ${{ needs.workflows_env.outputs.output_dockerhub_enabled == 'true' }}
        uses: docker/login-action@v2
        with:
          username: ${{ needs.workflows_env.outputs.dockerhub_username }}
          password: ${{ secrets.dockerhub_token }}

      # Log into ghcr.io
      - name: Login to GitHub Container Registry
        if: ${{ needs.workflows_env.outputs.output_ghcr_io_enabled == 'true' }}
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ needs.workflows_env.outputs.ghcr_repo_owner }}
          password: ${{ secrets.ghcr_token }}

      # Set up QEMU for multi-arch builds
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Run Docker on tmpfs
        if: ${{ needs.workflows_env.outputs.build_with_tmpfs == 'true' }}
        uses: JonasAlfredsson/docker-on-tmpfs@v1
        with:
          tmpfs_size: 5
          swap_size: 4
          swap_location: "/mnt/swapfile"

      # Set up buildx
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2

      # Cache build of linux/amd64 image & get image version from build output
      - name: Cache build of image
        id: cache_build
        uses: docker/build-push-action@v3
        with:
          context: ${{ needs.workflows_env.outputs.docker_build_context }}
          file: ${{ needs.workflows_env.outputs.docker_build_file }}
          platforms: linux/amd64
          tags: cached_build:latest
          load: true

      # Determine image version
      - name: Determine image version
        if: ${{ needs.workflows_env.outputs.build_version_specific }}
        id: image_version
        run: |
          set -x
          case "${{ needs.workflows_env.outputs.get_version_method }}" in
            cargo_toml_file_in_repo)
              VERSION=$(cat ./${{ needs.workflows_env.outputs.get_version_method_cargo_toml_file_in_repo }} | grep '\[package\]' -A9999 | grep -m 1 'version = ' | tr -d " " | tr -d '"' | tr -d "'" | cut -d = -f 2 )
              ;;
            cargo_toml_file_in_image)
              VERSION=$(docker run --rm --entrypoint cat cached_build:latest ${{ needs.workflows_env.outputs.get_version_method_cargo_toml_file_in_image }} | grep '\[package\]' -A9999 | grep -m 1 'version = ' | tr -d " " | tr -d '"' | tr -d "'" | cut -d = -f 2 )
              ;;
            file_in_container)
              VERSION=$(docker run --rm --entrypoint cat cached_build:latest ${{ needs.workflows_env.outputs.get_version_method_file_in_container }})
              ;;
            git_commit_hash_short)
              GIT_HEAD=$(git rev-parse HEAD)
              VERSION="${GIT_HEAD::7}"
              ;;
          esac
          if [[ -z "${VERSION}" ]]; then
            echo "::warning title=${{ github.job }} (manifest): No image version::No image version output returned, cannot build version specific images"
            echo "::set-output name=build_version_specific::false"
          else
            echo "::set-output name=build_version_specific::true"
            echo "::set-output name=image_version::${VERSION}"
          fi

      # Determine image names/tags
      - name: Determine image names/tags
        id: image_names_tags
        run: |
          set -x
          IMAGE_NAMES=()
          if [[ "${{ needs.workflows_env.outputs.output_dockerhub_enabled }}" == 'true' ]]; then
            IMAGE_NAMES+=("${{ needs.workflows_env.outputs.dockerhub_profile }}/${{ needs.workflows_env.outputs.dockerhub_repo }}")
          fi
          if [[ "${{ needs.workflows_env.outputs.output_ghcr_io_enabled }}" == 'true' ]]; then
            IMAGE_NAMES+=("ghcr.io/${{ needs.workflows_env.outputs.ghcr_repo }}")
          fi
          if [[ "${{ needs.workflows_env.outputs.push_enabled }}" == "false" ]]; then
            IMAGE_NAMES+=("test_build")
          fi
          printf -v IMAGE_NAMES_CSV '%s,' "${IMAGE_NAMES[@]}"
          echo "::set-output name=names::${IMAGE_NAMES_CSV::-1}"
          IMAGE_TAGS=()
          if [[ ${{ steps.image_version.outputs.build_version_specific }} == "true" ]]; then
            IMAGE_TAGS+=("${{ steps.image_version.outputs.image_version }}")
          fi
          if [[ ${{ needs.workflows_env.outputs.build_latest }} == "true" ]]; then
            IMAGE_TAGS+=("latest")
          fi
          printf -v IMAGE_TAGS_CSV '%s,' "${IMAGE_TAGS[@]}"
          echo "::set-output name=tags::${IMAGE_TAGS_CSV::-1}"
          IMAGE_FULL_TAGS=()
          for IMAGE_NAME in "${IMAGE_NAMES[@]}"; do
            for IMAGE_TAG in "${IMAGE_TAGS[@]}"; do
              IMAGE_FULL_TAGS+=("$IMAGE_NAME:$IMAGE_TAG")
            done
          done
          printf -v IMAGE_FULL_TAGS_CSV '%s,' "${IMAGE_FULL_TAGS[@]}"
          echo "::set-output name=full_name_tags::${IMAGE_FULL_TAGS_CSV::-1}"

      # Get metadata from repo
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ steps.image_names_tags.outputs.names }}

      # Build & push final images
      - name: Build & Push Final Image
        id: final_build
        uses: docker/build-push-action@v3
        with:
          context: ${{ needs.workflows_env.outputs.docker_build_context }}
          file: ${{ needs.workflows_env.outputs.docker_build_file }}
          platforms: ${{ needs.workflows_env.outputs.platforms_csv }}
          tags: ${{ steps.image_names_tags.outputs.full_name_tags }}
          labels: ${{ steps.meta.outputs.labels }}
          push: ${{ needs.workflows_env.outputs.push_enabled }}

      # Report images
      - name: Log images built & pushed
        if: ${{ needs.workflows_env.outputs.push_enabled == 'true' }}
        run: |
          echo "::notice title=${{ github.job }} (manifest): Images built & pushed::${{ steps.image_names_tags.outputs.full_name_tags }}"

  build_platform_specific_nohealthcheck:
    name: Build nohealthcheck
    if: needs.workflows_env.outputs.build_single_arch == 'true'
    runs-on: ubuntu-latest
    needs: [workflows_env]
    strategy:
      matrix: ${{fromJson(needs.workflows_env.outputs.platforms_matrix_json)}}

    steps:
      # Check out code
      - name: Checkout
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Populate cache
      - name: "check 'cache_enabled'"
        if: ${{ inputs.cache_enabled }}
        id: populate_cache
        uses: actions/cache@v3
        with:
          path: ${{ inputs.cache_path }}
          key: ${{ inputs.cache_key }}

      # Determine single arch suffix
      - name: Determine platform suffix
        id: platform_suffix
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        run: |
          set -x
          ARCH_SUFFIX=$(echo "${{ matrix.platform }}" | tr "/" "_")
          echo "::set-output name=platform_suffix::${ARCH_SUFFIX,,}"

      # Log into dockerhub
      - name: Login to DockerHub
        if: |
          needs.workflows_env.outputs.output_dockerhub_enabled == 'true' &&
          needs.workflows_env.outputs.build_nohealthcheck == 'true'
        uses: docker/login-action@v2
        with:
          username: ${{ needs.workflows_env.outputs.dockerhub_username }}
          password: ${{ secrets.dockerhub_token }}

      # Log into ghcr.io
      - name: Login to GitHub Container Registry
        if: |
          needs.workflows_env.outputs.output_ghcr_io_enabled == 'true' &&
          needs.workflows_env.outputs.build_nohealthcheck == 'true'
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ needs.workflows_env.outputs.ghcr_repo_owner }}
          password: ${{ secrets.ghcr_token }}

      - name: Run Docker on tmpfs
        if: ${{ needs.workflows_env.outputs.build_with_tmpfs == 'true' }}
        uses: JonasAlfredsson/docker-on-tmpfs@v1
        with:
          tmpfs_size: 5
          swap_size: 4
          swap_location: "/mnt/swapfile"

      # Set up QEMU for multi-arch builds
      - name: Set up QEMU
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        uses: docker/setup-qemu-action@v2

      # Set up buildx
      - name: Set up Docker Buildx
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: buildx
        uses: docker/setup-buildx-action@v2

      # Patch dockerfile to remove healthcheck
      - name: Patch Dockerfile to remove healthcheck
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        run: sed '/^HEALTHCHECK /d' < ${{ needs.workflows_env.outputs.docker_build_file }} > ${{ needs.workflows_env.outputs.docker_build_file }}.nohealthcheck

      # Cache build of image & get image version from build output
      - name: Cache build of image
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: cache_build
        uses: docker/build-push-action@v3
        with:
          context: ${{ needs.workflows_env.outputs.docker_build_context }}
          file: ${{ needs.workflows_env.outputs.docker_build_file }}.nohealthcheck
          platforms: ${{ matrix.platform }}
          tags: cached_build:${{ steps.platform_suffix.outputs.platform_suffix }}
          load: true

      # Determine image version
      - name: Determine image version
        if: |
          needs.workflows_env.outputs.build_version_specific == 'true' &&
          needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: image_version
        run: |
          set -x
          case "${{ needs.workflows_env.outputs.get_version_method }}" in
            cargo_toml_file_in_repo)
              VERSION=$(cat ./${{ needs.workflows_env.outputs.get_version_method_cargo_toml_file_in_repo }} | grep '\[package\]' -A9999 | grep -m 1 'version = ' | tr -d " " | tr -d '"' | tr -d "'" | cut -d = -f 2 )
              ;;
            cargo_toml_file_in_image)
              VERSION=$(docker run --rm --entrypoint cat cached_build:${{ steps.platform_suffix.outputs.platform_suffix }} ${{ needs.workflows_env.outputs.get_version_method_cargo_toml_file_in_image }} | grep '\[package\]' -A9999 | grep -m 1 'version = ' | tr -d " " | tr -d '"' | tr -d "'" | cut -d = -f 2 )
              ;;
            file_in_container)
              VERSION=$(docker run --rm --entrypoint cat cached_build:${{ steps.platform_suffix.outputs.platform_suffix }} ${{ needs.workflows_env.outputs.get_version_method_file_in_container }})
              ;;
            git_commit_hash_short)
              GIT_HEAD=$(git rev-parse HEAD)
              VERSION="${GIT_HEAD::7}"
              ;;
          esac
          if [[ -z "${VERSION}" ]]; then
            echo "::warning title=${{ github.job }} (${{ matrix.platform }}): No image version::No image version output returned, cannot build version specific images"
            echo "::set-output name=build_version_specific::false"
          else
            echo "::set-output name=build_version_specific::true"
            echo "::set-output name=image_version::${VERSION}"
          fi

      # Determine image names/tags
      - name: Determine image names/tags
        id: image_names_tags
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        run: |
          set -x
          IMAGE_NAMES=()
          if [[ "${{ needs.workflows_env.outputs.output_dockerhub_enabled }}" == 'true' ]]; then
            IMAGE_NAMES+=("${{ needs.workflows_env.outputs.dockerhub_profile }}/${{ needs.workflows_env.outputs.dockerhub_repo }}")
          fi
          if [[ "${{ needs.workflows_env.outputs.output_ghcr_io_enabled }}" == 'true' ]]; then
            IMAGE_NAMES+=("ghcr.io/${{ needs.workflows_env.outputs.ghcr_repo }}")
          fi
          if [[ "${{ needs.workflows_env.outputs.push_enabled }}" == "false" ]]; then
            IMAGE_NAMES+=("test_build")
          fi
          printf -v IMAGE_NAMES_CSV '%s,' "${IMAGE_NAMES[@]}"
          echo "::set-output name=names::${IMAGE_NAMES_CSV::-1}"
          IMAGE_TAGS=()
          if [[ ${{ steps.image_version.outputs.build_version_specific }} == "true" ]]; then
            IMAGE_TAGS+=("${{ steps.image_version.outputs.image_version }}_${{ steps.platform_suffix.outputs.platform_suffix }}_nohealthcheck")
          fi
          if [[ ${{ needs.workflows_env.outputs.build_latest }} == "true" ]]; then
            IMAGE_TAGS+=("latest_${{ steps.platform_suffix.outputs.platform_suffix }}_nohealthcheck")
          fi
          printf -v IMAGE_TAGS_CSV '%s,' "${IMAGE_TAGS[@]}"
          echo "::set-output name=tags::${IMAGE_TAGS_CSV::-1}"
          IMAGE_FULL_TAGS=()
          for IMAGE_NAME in "${IMAGE_NAMES[@]}"; do
            for IMAGE_TAG in "${IMAGE_TAGS[@]}"; do
              IMAGE_FULL_TAGS+=("$IMAGE_NAME:$IMAGE_TAG")
            done
          done
          printf -v IMAGE_FULL_TAGS_CSV '%s,' "${IMAGE_FULL_TAGS[@]}"
          echo "::set-output name=full_name_tags::${IMAGE_FULL_TAGS_CSV::-1}"

      # Get metadata from repo
      - name: Extract metadata (tags, labels) for Docker
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ steps.image_names_tags.outputs.names }}

      # Push final image
      - name: Build & Push Final Image
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: final_build
        uses: docker/build-push-action@v3
        with:
          context: ${{ needs.workflows_env.outputs.docker_build_context }}
          file: ${{ needs.workflows_env.outputs.docker_build_file }}.nohealthcheck
          platforms: ${{ matrix.platform }}
          tags: ${{ steps.image_names_tags.outputs.full_name_tags }}
          labels: ${{ steps.meta.outputs.labels }}
          push: ${{ needs.workflows_env.outputs.push_enabled }}

      # Report images
      - name: Log images built & pushed
        if: |
          needs.workflows_env.outputs.push_enabled == 'true' &&
          needs.workflows_env.outputs.build_nohealthcheck == 'true'
        run: |
          echo "::notice title=${{ github.job }} (${{ matrix.platform }}): Images built & pushed::${{ steps.image_names_tags.outputs.full_name_tags }}"

  build_nohealthcheck:
    name: Build nohealthcheck (manifest)
    if: needs.workflows_env.outputs.build_multi_arch == 'true'
    runs-on: ubuntu-latest
    needs: [workflows_env]

    steps:
      # Check out code
      - name: Checkout
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Populate cache
      - name: "check 'cache_enabled'"
        if: ${{ inputs.cache_enabled }}
        id: populate_cache
        uses: actions/cache@v3
        with:
          path: ${{ inputs.cache_path }}
          key: ${{ inputs.cache_key }}

      # Log into dockerhub
      - name: Login to DockerHub
        if: |
          needs.workflows_env.outputs.output_dockerhub_enabled == 'true' &&
          needs.workflows_env.outputs.build_nohealthcheck == 'true'
        uses: docker/login-action@v2
        with:
          username: ${{ needs.workflows_env.outputs.dockerhub_username }}
          password: ${{ secrets.dockerhub_token }}

      # Log into ghcr.io
      - name: Login to GitHub Container Registry
        if: |
          needs.workflows_env.outputs.output_ghcr_io_enabled == 'true' &&
          needs.workflows_env.outputs.build_nohealthcheck == 'true'
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ needs.workflows_env.outputs.ghcr_repo_owner }}
          password: ${{ secrets.ghcr_token }}

      - name: Run Docker on tmpfs
        if: ${{ needs.workflows_env.outputs.build_with_tmpfs == 'true' }}
        uses: JonasAlfredsson/docker-on-tmpfs@v1
        with:
          tmpfs_size: 5
          swap_size: 4
          swap_location: "/mnt/swapfile"

      # Set up QEMU for multi-arch builds
      - name: Set up QEMU
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        uses: docker/setup-qemu-action@v2

      # Set up buildx
      - name: Set up Docker Buildx
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: buildx
        uses: docker/setup-buildx-action@v2

      # Patch dockerfile to remove healthcheck
      - name: Patch Dockerfile to remove healthcheck
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        run: sed '/^HEALTHCHECK /d' < ${{ needs.workflows_env.outputs.docker_build_file }} > ${{ needs.workflows_env.outputs.docker_build_file }}.nohealthcheck

      # Cache build of linux/amd64 image & get image version from build output
      - name: Cache build of image
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: cache_build
        uses: docker/build-push-action@v3
        with:
          context: ${{ needs.workflows_env.outputs.docker_build_context }}
          file: ${{ needs.workflows_env.outputs.docker_build_file }}.nohealthcheck
          platforms: linux/amd64
          tags: cached_build:latest
          load: true

      # Determine image version
      - name: Determine image version
        if: |
          needs.workflows_env.outputs.build_version_specific == 'true' &&
          needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: image_version
        run: |
          set -x
          case "${{ needs.workflows_env.outputs.get_version_method }}" in
            cargo_toml_file_in_repo)
              VERSION=$(cat ./${{ needs.workflows_env.outputs.get_version_method_cargo_toml_file_in_repo }} | grep '\[package\]' -A9999 | grep -m 1 'version = ' | tr -d " " | tr -d '"' | tr -d "'" | cut -d = -f 2 )
              ;;
            cargo_toml_file_in_image)
              VERSION=$(docker run --rm --entrypoint cat cached_build:latest ${{ needs.workflows_env.outputs.get_version_method_cargo_toml_file_in_image }} | grep '\[package\]' -A9999 | grep -m 1 'version = ' | tr -d " " | tr -d '"' | tr -d "'" | cut -d = -f 2 )
              ;;
            file_in_container)
              VERSION=$(docker run --rm --entrypoint cat cached_build:latest ${{ needs.workflows_env.outputs.get_version_method_file_in_container }})
              ;;
            git_commit_hash_short)
              GIT_HEAD=$(git rev-parse HEAD)
              VERSION="${GIT_HEAD::7}"
              ;;
          esac
          if [[ -z "${VERSION}" ]]; then
            echo "::warning title=${{ github.job }} (manifest): No image version::No image version output returned, cannot build version specific images"
            echo "::set-output name=build_version_specific::false"
          else
            echo "::set-output name=build_version_specific::true"
            echo "::set-output name=image_version::${VERSION}"
          fi

      # Determine image names/tags
      - name: Determine image names/tags
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: image_names_tags
        run: |
          set -x
          IMAGE_NAMES=()
          if [[ "${{ needs.workflows_env.outputs.output_dockerhub_enabled }}" == 'true' ]]; then
            IMAGE_NAMES+=("${{ needs.workflows_env.outputs.dockerhub_profile }}/${{ needs.workflows_env.outputs.dockerhub_repo }}")
          fi
          if [[ "${{ needs.workflows_env.outputs.output_ghcr_io_enabled }}" == 'true' ]]; then
            IMAGE_NAMES+=("ghcr.io/${{ needs.workflows_env.outputs.ghcr_repo }}")
          fi
          if [[ "${{ needs.workflows_env.outputs.push_enabled }}" == "false" ]]; then
            IMAGE_NAMES+=("test_build")
          fi
          printf -v IMAGE_NAMES_CSV '%s,' "${IMAGE_NAMES[@]}"
          echo "::set-output name=names::${IMAGE_NAMES_CSV::-1}"
          IMAGE_TAGS=()
          if [[ ${{ steps.image_version.outputs.build_version_specific }} == "true" ]]; then
            IMAGE_TAGS+=("${{ steps.image_version.outputs.image_version }}_nohealthcheck")
          fi
          if [[ ${{ needs.workflows_env.outputs.build_latest }} == "true" ]]; then
            IMAGE_TAGS+=("latest_nohealthcheck")
          fi
          printf -v IMAGE_TAGS_CSV '%s,' "${IMAGE_TAGS[@]}"
          echo "::set-output name=tags::${IMAGE_TAGS_CSV::-1}"
          IMAGE_FULL_TAGS=()
          for IMAGE_NAME in "${IMAGE_NAMES[@]}"; do
            for IMAGE_TAG in "${IMAGE_TAGS[@]}"; do
              IMAGE_FULL_TAGS+=("$IMAGE_NAME:$IMAGE_TAG")
            done
          done
          printf -v IMAGE_FULL_TAGS_CSV '%s,' "${IMAGE_FULL_TAGS[@]}"
          echo "::set-output name=full_name_tags::${IMAGE_FULL_TAGS_CSV::-1}"

      # Get metadata from repo
      - name: Extract metadata (tags, labels) for Docker
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ steps.image_names_tags.outputs.names }}

      # Build & push final images
      - name: Build & Push Final Image
        if: needs.workflows_env.outputs.build_nohealthcheck == 'true'
        id: final_build
        uses: docker/build-push-action@v3
        with:
          context: ${{ needs.workflows_env.outputs.docker_build_context }}
          file: ${{ needs.workflows_env.outputs.docker_build_file }}.nohealthcheck
          platforms: ${{ needs.workflows_env.outputs.platforms_csv }}
          tags: ${{ steps.image_names_tags.outputs.full_name_tags }}
          labels: ${{ steps.meta.outputs.labels }}
          push: ${{ needs.workflows_env.outputs.push_enabled }}

      # Report images
      - name: Log images built & pushed
        if: |
          needs.workflows_env.outputs.push_enabled == 'true' &&
          needs.workflows_env.outputs.build_nohealthcheck == 'true'
        run: |
          echo "::notice title=${{ github.job }} (manifest): Images built & pushed::${{ steps.image_names_tags.outputs.full_name_tags }}"
